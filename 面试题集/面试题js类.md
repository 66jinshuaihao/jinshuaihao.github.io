## 数组去重

```
声明空数组 进行遍历只添加没有的字符串
arr = ['blue', 'green', 'blue', 'yellow', 'black', 'yellow', 'blue', 'green', 'blue', 'blue', 'blue'];
function unique(arr) {
var newArr = [];
for (var i = 0; i < arr.length; i++) {
if (newArr.indexOf(arr[i]) === -1) {
newArr.push(arr[i]);
}
}
return newArr;
}
console.log(unique(arr));


双重循环 删除和外循环想听的下标数字
  arr = ['blue', 'green', 'blue', 'yellow', 'black', 'yellow', 'blue', 'green', 'blue', 'blue', 'blue'];
    function unique(arr) {
        for (let i = 0; i < arr.length; i++) {
            for (let j = i + 1; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    arr.splice(j, 1);
                    j--;
                }
            }
        }
        return arr;
    }
    console.log(unique(arr));
```

## 描述 cookies. sessionStorage 和 localStorage 的区别

    (1 )数据存储大小限制不同。

    cookies:数据始终携带在同源 https 请求中,即 cookies 可以在服务 器和浏览器之间传回。所以存储的数据量最小,一般为 4096B.

    sessionStorage:数据存储在本地,不会自动发送到服务器。一般 5M 以上;

    localStorage:数据存储在本地,不会自动发送到服务器。一般 5M 以 上；

    (2)数据有效期不同。

    Cookies:数据在 cookie 设置的过期日期之前有效,即使窗口和浏览器已关闭。

    sessionStorage:关闭浏览器窗口后自动清除数据。存储的数据只在同一一个源窗口有效,即使在不同浏览器的同一个页面也是无效的,一般用于 session 数据的存储;

    localStorage: 一直有效,所以作为持久化数据使用。

     (3)数据范围不同。

    cookies、localStorage: 在所有同源窗口之间敏感共享

    sessionStorage:不在不同浏览器窗口之间共享

    同源窗口共享是一款连接 PC 和移动设备的软件。使用同源窗口共享,您可以轻松地在 PC 和移动设备之间共享屏幕内容和数据。

## data-attribute'的目的是什么?

    data-attribute 是 html5 引入的新特性。前端开发者可以使用它来设置需要的自定义属性来存储一-些数据。 当然,在高级浏览器中,可以通过 JS 脚本进行定义和数据访问。


    ## 6.您如何优化您的网站文件和资源?

    文件合并、文件压缩、使用 cdn(内容分发网络)托管您的资产、使用缓存、优化元标记、启用 css/js 文件的 Gzip 压缩。

    将 css/js 文件放在外部文件中，避免写在同-个页面，引用时把 css 放在最上面，把 js 放在最下面等等。

## javascript 数据类型:

    值类型(基本类型): String、 Number、 Boolean、 Null、 Undefined、 Symbol。

    参考数据类型:对象(Object)、 数组(Array)、 函数(Function)。

## js 中 var 和 let 与 const 的区别

    var 声明的变量属于函数作用域，let 和 const 声明的变 量属于块作用域;

    Var 有变量提升的现象，而 let 和 const 则没有;

    var 变量可以重复声明，而在同一个块级作用域内，let 变 量不能重新声明，const 变量不能修改。

## Flash 和 AJAX 各自的优缺点，在使用中如何取舍？

```
Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。
Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
```

## map 和 foreach 区别是什么？

```
相同点：
1、都是遍历数组
2、匿名函数中的this都是指向window

区别：
map方法：返回一个新的数组，不改变原数组

array.map((item, index, array)=>{
    //do something
})

forEach方法：没有返回值，可以改变原数组

array.forEach((item, index, array)=>{
    //do something
})

```

## const 问题

```
说明:Firefox下,可以使用const关键字或var关键字来定义常量;
IE下,只能使用var关键字来定义常量.
**解决方法：**统一使用var关键字来定义常量
```

## 为啥说 react 比 jquery 效率高

```
组件化开发，优势明显

虚拟dom,加速代码的渲染

数据双向绑定，避免了许多不必要的找对象

渐进式，本身只处理 UI ，可以和你的其它技术栈组合到一起来使用

声明（配置）式设计：做的好处就是按照我们约定好的方式来开发，所有人写出来的代码就像一个人写的
```

## 说说写 JavaScript 的基本规范？

```
1 不要在同一行声明多个变量
2 使用 ===或!==来比较 true/false 或者数值
3 switch 必须带有 default 分支
4 函数应该有返回值
5 for if else 必须使用大括号
6 语句结束加分号
7 命名要有意义，使用驼峰命名法
```

## Ajax 使用

```
全称 ： Asynchronous Javascript And XML
所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。
创建Ajax的过程：
1 创建XMLHttpRequest对象（异步调用对象）
2 创建新的Http请求（方法、URL、是否异步）
3 设置响应HTTP请求状态变化的函数。
onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。
4 发送http请求
5 获取异步调用返回的数据
注意：
1 页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。
2 同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。
3 尽量减少ajax请求次数
4 ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。
```

## 栈和堆的区别？

```
栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；
堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。
```

## 谈谈 this 的理解

```
1 this 总是指向函数的直接调用者（而非间接调用者）
2 如果有 new 关键字，this 指向 new 出来的那个对象
3 在事件中，this 指向目标元素，特殊的是 IE 的 attachEvent 中的 this 总是指向全局对象 window。
```

## eval 是做什么的？

```
它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）
```

## 什么是深/浅拷贝，有哪些实现方式

```
基本数据类型：string、number、boolean、undefined、null
引用数据类型：object、array、function
JS数据类型分为基本数据类型和引用数据类型，基本数据类型保存的是值，引用类型保存的是引用地址(this指针)。浅拷贝共用一个引用地址，深拷贝会创建新的内存地址。
Object.assign：对象的合并 （第一级属性深拷贝，第一级以下的级别属性浅拷贝。）
ES6中的 Object.assign()，第一个参数必须是个空对象。
Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象
```

## 什么是闭包

```
含义：闭包指的是函数内部可以访问其他作用域内变量的函数

闭包的特点：

1、外层函数嵌套内层函数，外层函数将内层函数的值返回出去

2、闭包能够访问其他作用域内的变量

3、函数的参数和变量不会被垃圾回收机制回收

4、允许私有成员存在

闭包的缺点

由于闭包不会被垃圾回收机制回收的这个特点导致当你不再使用这个闭包时闭包的参数和变量仍然存储在内存当中容易造成内存泄漏

工作中什么情况下要用到闭包？

在我们工作中使用闭包的常见场景是用来模拟一个块级作用域(匿名自执行函数)和对一些函数的参数结构进行缓存，但是因为闭包容易造成内存泄漏的特点我们在使用完闭包之后要手动将结果进行清除
```

## 继承有哪些方法

```
原型链继承
借用构造函数继承（伪造对象、经典继承）
实例继承（原型式继承）
组合式继承
寄生组合继承
es6继承 extends
```

## js 获取原型的方法？

```
p.proto

p.constructor.prototype

Object.getPrototypeOf(p)
```

## {} 和 [] 的 valueOf 和 toString 的结果是什么？

```
{} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"

[] 的 valueOf 结果为 [] ，toString 的结果为 ""
```

## 什么情况下会发生布尔值的隐式强制类型转换？

```
（1） if (..) 语句中的条件判断表达式。
（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。
（3） while (..) 和 do..while(..) 循环中的条件判断表达式。
（4） ? : 中的条件判断表达式。
（5） 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）。
```

## || 和 && 操作符的返回值？

```
|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件
判断。

对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。

&& 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。

|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果
```

## Symbol 值的强制类型转换？

```
ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。

Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果
都是 true ）。
```

## 什么是宏任务，什么是微任务\*\*

```
答：**宏任务和微任务都是异步任务在同步任务队列之后
而宏任务一般是:包括整体代码script, setTimeout, setInterval、 setlmmediate（node 独有）。
微任务:原生Promise(有些实现的promise将then方法放到了宏任务中)、
process.nextTick、Object.observe(已废弃)记住就行了new.promise是宏任务。
执行顺序
微观任务先于宏观任务
```

## jquery 和 javascript 的区别

```
jQuery 是 JavaScript 的一个封装集合。封装了很多 JavaScript 的方法，也就是说，jQuery 里面的内容都是 JavaScript 语句。只是封装起来让我们学习和使用的简单一些.
```

## new 一个对象，这个过程中发生了什么

```
var obj = new Object("name","sansan");

创建一个新对象，如：var obj = {};

新对象的_proto_属性指向构造函数的原型对象。

将构造函数的作用域赋值给新对象。（所以this对象也指向新对象）

执行构造函数内部的代码，将属性添加给obj中的this对象。

返回新对象obj。
```

## 事件是什么

```
事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。
```

## 使用箭头函数应该注意什么？（箭头函数和 function 的区别）

```
 （1）用了箭头函数，this就不是指向window 而是声明时的外部环境
 （2）箭头函数不可以使用arguments（参数的集合）对象
 （3）箭头函数不能使用构造函数，也就是说不能使用new命令，否则会抛出一个错误
```

## JavaScript 原型，原型链 ? 有什么特点？

```
每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，
如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，
于是就这样一直找下去，也就是我们平时所说的原型链的概念。
关系：instance.constructor.prototype = instance.proto
特点：
JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。
```

## ajax 过程？

```
(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.
(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
(3)设置响应HTTP请求状态变化的函数.
(4)发送HTTP请求.
(5)获取异步调用返回的数据.
(6)使用JavaScript和DOM实现局部刷新.
```

## attribute 和 property 的区别

```
attribute 是 dom 元素在文档中作为 html 标签拥有的属性，而 property 就是 dom 元素在 JS 中作为对象拥有的属性。对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的。
```

## 什么是进程，什么是线程

```
进程是：一个程序的运行到结束就是一个进程，运行的过程中有多个持续的或者断断续续的片段组成，这就是线程，一个进程包含多个线程。Js 是单线程。
```

## 一次完整的 HTTP 事务是怎样的一个过程？

```
基本流程：

a. 域名解析

b. 发起 TCP 的 3 次握手

c. 建立 TCP 连接后发起 http 请求

d. 服务器端响应 http 请求，浏览器得到 html 代码

e. 浏览器解析 html 代码，并请求 html 代码中的资源

f. 浏览器对页面进行渲染呈现给用户
```

## this

```
this 是 JavaScript 语言的一个关键字。在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）。this 总是指向函数的直接调用者。如果有 new 关键字，this 指向 new 出来的对象。在事件中，this 指向触发这个事件的对象。
```

## 什么是假值对象？

```
浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。
```

## 什么是 DOM 和 BOM？

```
DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。

BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的方法和接口。BOM 的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。
```

## 介绍 JS 有哪些内置对象？

```
Object 是 JavaScript 中所有对象的父对象
数据封装类对象：Object、Array、Boolean、Number、String
其它对象：Function、Arguments、Math、Date、RegExp、Error
```

## defer 和 async 并行加载 js 文件的区别？

```
defer 并行加载 js 文件，会按照页面上 script 标签的顺序执行
async 并行加载 js 文件，下载完成立即执行，不会按照页面上 script 标签的顺序执行
```

## 说说你对事件流的理解

```
事件流分为两种：捕获事件流和冒泡事件流
捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找到执行目标节点
冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到根节点
```

## JavaScript 自定义事件

```
document.createEvent() 创建事件模型
event.initEvent() 初始化事件
element.dispatchEvent() 触发事件
```

## JS 中常见的内存泄露

```
意外的全局变量
被遗忘的计时器或回调函数
脱离DOM的引用
闭包
```

## 箭头函数和普通函数在语法和特性上有以下区别：

```
语法：箭头函数使用 => 符号来定义函数，而普通函数使用 function 关键字。

this 绑定：箭头函数的 this 值是定义时所在的对象（即当前上下文），而不是运行时所在的对象。普通函数中的 this 值则是调用时所在的对象。

arguments 对象：箭头函数没有自己的 arguments 对象，而是继承其所在作用域的 arguments 对象。普通函数中有自己的 arguments 对象，其中包含了所有传入的参数。

构造函数：箭头函数不能用作构造函数，因为它们没有自己的 this 值。普通函数可以被用作构造函数来创建新的对象实例。

返回值：箭头函数如果只有一条表达式，会自动将该表达式的结果作为返回值。普通函数需要使用 return 语句显式返回值。
```

## Promise 和 async/await 都是 JavaScript 异步编程的解决方案，它们有以下区别：

```
语法：Promise 使用链式调用 .then() 和 .catch() 方法来处理异步操作的结果。而 async/await 使用更类似于同步代码的 try/catch 块来处理异步操作的结果。

错误处理：在 Promise 中，错误必须通过 .catch() 方法或者在 .then() 方法内部使用 try/catch 块来捕获和处理。而在 async/await 中，则可以使用 try/catch 块来捕获异步操作中的错误。

可读性：async/await 代码通常比 Promise 更容易阅读和理解，因为它们更接近于同步代码。

执行顺序：Promise 是基于回调函数的异步编程方式，可以使用 .then() 方法来指定每个异步操作完成后执行的下一步操作。而 async/await 的执行顺序则更像是同步代码，程序会等待异步操作完成后再继续执行下一行代码。

```

## 请解释一下 JavaScript 中的异步编程？

```
异步编程是指程序不需要等待某些操作完成才能继续处理其他操作，而是可以同时执行多个任务。JavaScript中的异步编程可以通过回调函数、Promise和async/await等方式实现。
```

## 请解释一下 JavaScript 中的原型链？

```
JavaScript中的原型链是由每个对象的__proto__属性所组成的。当访问一个对象的属性时，如果该属性不存在，则会沿着该对象的原型链逐级向上查找，直到找到该属性或者达到最顶层的Object对象为止。这个特性使得JavaScript可以实现面向对象编程中的继承和多态等概念。
```

## 什么是函数防抖和函数节流

```
防抖（debounce）和节流（throttle）都是用来控制某个函数在一定时间内执行多少次的技巧，两者相似而又不同。
背后的基本思想是 某些代码不可以在没有间断的情况下连续重复执行。
```

## 为什么需要函数防抖和函数节流？

```
在浏览器中某些计算和处理要比其他的昂贵很多。例如DOM操作比起非DOM交互需要更多的内存和CPU占用时间。连续尝试进行过多的DOM操作可能会导致浏览器挂起，甚至崩溃；
例如当调整浏览器大小的时候，resize事件会连续触发；如果在resize事件处理程序内部尝试进行DOM操作，其高频率的更改可能会让浏览器崩溃；
为了绕开上面的问题，需要对该类函数进行节流；
```

## 函数防抖 (debounce) 函数节流 (throttle)

```
函数防抖 (debounce)
如果一个事件被频繁触发多次，并且触发的时间间隔过短，则防抖函数可以使得对应的事件处理函数只执行最后触发的一次。
函数防抖可以把多个顺序的调用合并成一次。

函数节流 (throttle)
如果一个事件被频繁触发多次，节流函数可以按照固定频率去执行对应的事件处理方法。
函数节流保证一个事件一定时间内只执行一次。
```

## 请解释一下 JavaScript 中的事件循环（Event Loop）？

```
事件循环是JavaScript中处理异步编程的机制。它不断地从任务队列中取出任务并执行，直到任务队列为空。当有新的任务加入时，它会被放入任务队列的末尾。
```

## 内存泄漏是指在程序中分配的内存没有被释放，导致程序中占用的内存越来越大，直至程序崩溃或系统资源耗尽。以下是常见导致内存泄漏的操作：

```
意外的全局变量：如果意外地声明了一个全局变量，它将一直存在于内存中，即使你不再需要使用它。

闭包：当函数返回后，闭包中仍然保留着对局部变量和参数的引用，这会阻止 JavaScript 垃圾回收器清除这些变量所占用的内存。

循环引用：两个对象之间相互引用并且都有一个属性指向另一个，当这种情况发生时，这些对象将永远无法被垃圾回收器处理并释放内存。

定时器：如果定时器没有被正确清除，它会一直在内存中运行，在时间到达时执行指定的代码，从而导致内存泄漏。

DOM 引用：在JavaScript中，DOM 对象是非常重要的，但它们也可能造成内存泄漏。如果你没有正确地删除元素，它们将继续留在内存中，消耗系统资源。

大量数据缓存：如果你在浏览器端缓存了大量数据，而且没有及时清理它们，就会导致内存泄漏。

总之，内存泄漏是由于程序中存在未释放的内存，导致系统资源被耗尽，并可能引起程序崩溃。程序员应该避免以上操作，正确地释放内存，以提高程序的性能和稳定性。
```

## webpack 和 gulp 区别（模块化与流的区别）

```
gulp 强调的是前端开发的工作流程，我们可以通过配置一系列的 task，定义 task 处
    理的事务（例如文件压缩合并、雪碧图、启动 server、版本控制等），然后定义执行
    顺序，来让 gulp 执行这些 task，从而构建项目的整个前端开发流程。
    webpack 是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图
    片、js 文件、css 文件等）都看成模块，通过 loader（加载器）和 plugins（插件）
    对资源进行处理，打包成符合生产环境部署的前端资源。
```

## 什么是虚拟 DOM？

```
虚拟 dom 是相对于浏览器所渲染出来的真实 dom 的，在 react ，vue 等技术出现之
    前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom
    然后修改样式行为或者结构，来达到更新 ui 的目的。
    这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果
    建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示
    dom 树，那么每次 dom 的更改就变成了 js 对象的属性的更改，这样一来就能查找
    js 对象的属性变化要比查询 dom 树的性能开销小。
```

## 状态码 304 和 200

```
状态码 200：请求已成功，请求所希望的响应头或数据体将随此响应返回。即返回的数
    据为全量的数据，如果文件不通过 GZIP 压缩的话，文件是多大，则要有多大传输量。
    状态码 304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的
    内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状
    态码。即客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有
    修改过，则不需要返回全量的数据。
```

## cache-control 的值有哪些

```
cache-control 是一个通用消息头字段被用于 HTTP 请求和响应中，通过指定指令来实
    现缓存机制，这个缓存指令是单向的，常见的 取值有 private 、no-cache、max-age、
    must-revalidate 等，默认为 private。
```

## 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？

    ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let、const、class 命令声明的全局变量，不属于顶层对象的属性。只在一个块级作用域（Script）中，获取时不加 window/global 就好：

## JS 是一门面向对象的语言，说说面向对象语言的三大特征？

```
封装、继承、多态
```

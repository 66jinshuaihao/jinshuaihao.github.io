## 1. JS 中常见的内存泄露

```
意外的全局变量
被遗忘的计时器或回调函数
脱离DOM的引用
闭包
```

## 2. 箭头函数和普通函数在语法和特性上有以下区别：

```
语法：箭头函数使用 => 符号来定义函数，而普通函数使用 function 关键字。

this 绑定：箭头函数的 this 值是定义时所在的对象（即当前上下文），而不是运行时所在的对象。普通函数中的 this 值则是调用时所在的对象。

arguments 对象：箭头函数没有自己的 arguments 对象，而是继承其所在作用域的 arguments 对象。普通函数中有自己的 arguments 对象，其中包含了所有传入的参数。

构造函数：箭头函数不能用作构造函数，因为它们没有自己的 this 值。普通函数可以被用作构造函数来创建新的对象实例。

返回值：箭头函数如果只有一条表达式，会自动将该表达式的结果作为返回值。普通函数需要使用 return 语句显式返回值。
```

## 3.Promise 和 async/await 都是 JavaScript 异步编程的解决方案，它们有以下区别：

```
语法：Promise 使用链式调用 .then() 和 .catch() 方法来处理异步操作的结果。而 async/await 使用更类似于同步代码的 try/catch 块来处理异步操作的结果。

错误处理：在 Promise 中，错误必须通过 .catch() 方法或者在 .then() 方法内部使用 try/catch 块来捕获和处理。而在 async/await 中，则可以使用 try/catch 块来捕获异步操作中的错误。

可读性：async/await 代码通常比 Promise 更容易阅读和理解，因为它们更接近于同步代码。

执行顺序：Promise 是基于回调函数的异步编程方式，可以使用 .then() 方法来指定每个异步操作完成后执行的下一步操作。而 async/await 的执行顺序则更像是同步代码，程序会等待异步操作完成后再继续执行下一行代码。

```

## 4 请解释一下 JavaScript 中的异步编程？

```
异步编程是指程序不需要等待某些操作完成才能继续处理其他操作，而是可以同时执行多个任务。JavaScript中的异步编程可以通过回调函数、Promise和async/await等方式实现。
```

## 5 请解释一下 JavaScript 中的原型链？

```
JavaScript中的原型链是由每个对象的__proto__属性所组成的。当访问一个对象的属性时，如果该属性不存在，则会沿着该对象的原型链逐级向上查找，直到找到该属性或者达到最顶层的Object对象为止。这个特性使得JavaScript可以实现面向对象编程中的继承和多态等概念。
```

## 6.什么是函数防抖和函数节流

```
防抖（debounce）和节流（throttle）都是用来控制某个函数在一定时间内执行多少次的技巧，两者相似而又不同。
背后的基本思想是 某些代码不可以在没有间断的情况下连续重复执行。
```

## 7.为什么需要函数防抖和函数节流？

```
在浏览器中某些计算和处理要比其他的昂贵很多。例如DOM操作比起非DOM交互需要更多的内存和CPU占用时间。连续尝试进行过多的DOM操作可能会导致浏览器挂起，甚至崩溃；
例如当调整浏览器大小的时候，resize事件会连续触发；如果在resize事件处理程序内部尝试进行DOM操作，其高频率的更改可能会让浏览器崩溃；
为了绕开上面的问题，需要对该类函数进行节流；
```

## 8. 函数防抖 (debounce) 函数节流 (throttle)

```
函数防抖 (debounce)
如果一个事件被频繁触发多次，并且触发的时间间隔过短，则防抖函数可以使得对应的事件处理函数只执行最后触发的一次。
函数防抖可以把多个顺序的调用合并成一次。

函数节流 (throttle)
如果一个事件被频繁触发多次，节流函数可以按照固定频率去执行对应的事件处理方法。
函数节流保证一个事件一定时间内只执行一次。
```

## 9.请解释一下 JavaScript 中的事件循环（Event Loop）？

```
事件循环是JavaScript中处理异步编程的机制。它不断地从任务队列中取出任务并执行，直到任务队列为空。当有新的任务加入时，它会被放入任务队列的末尾。
```

## 10 内存泄漏是指在程序中分配的内存没有被释放，导致程序中占用的内存越来越大，直至程序崩溃或系统资源耗尽。以下是常见导致内存泄漏的操作：

```
意外的全局变量：如果意外地声明了一个全局变量，它将一直存在于内存中，即使你不再需要使用它。

闭包：当函数返回后，闭包中仍然保留着对局部变量和参数的引用，这会阻止 JavaScript 垃圾回收器清除这些变量所占用的内存。

循环引用：两个对象之间相互引用并且都有一个属性指向另一个，当这种情况发生时，这些对象将永远无法被垃圾回收器处理并释放内存。

定时器：如果定时器没有被正确清除，它会一直在内存中运行，在时间到达时执行指定的代码，从而导致内存泄漏。

DOM 引用：在JavaScript中，DOM 对象是非常重要的，但它们也可能造成内存泄漏。如果你没有正确地删除元素，它们将继续留在内存中，消耗系统资源。

大量数据缓存：如果你在浏览器端缓存了大量数据，而且没有及时清理它们，就会导致内存泄漏。

总之，内存泄漏是由于程序中存在未释放的内存，导致系统资源被耗尽，并可能引起程序崩溃。程序员应该避免以上操作，正确地释放内存，以提高程序的性能和稳定性。
```
